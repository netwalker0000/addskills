:sh 创建一个shell
Ctrl-D 结束shell并回到vi

0 移到一行的开头
$ 移到一行的结尾

ZZ 保存并离开文件
e! 恢复上一次存储的文件内容发

e 到单词的结尾

i 插入
a 添加
c 更改
d 删除
y 拖曳
p 放置
. 重复命令

~ 更改大小写
r 替换一个字符
s 替换多个字符
x 删除字符

u 撤销
Ctrl-R 重做

A 在一行的结尾处附加文本
I 在一行的开头处插入文本
o 在光标的下一行打开新行
O 在光标的上一行打开新行
J 合并两行

C 可更改光标所在位置到此行结尾间的文本,它的功用和c$一样
R 进入覆盖模式，输入的字符将逐一覆盖屏幕上的字符
S 更改一整行文本
D 删除从光标所在位置到本行结束间的文本
P 将文本放置在光标前
Y 拖曳一整行文本，与yy行为完全一样

U 恢复一整行成原来面貌

c 可以与光标移动命令一起使用
cw c2b c$ c0 cc

y 可与任何光标移动命令合并使用
yw y$ 4yy

yy 用于拖曳一整行的文本

除了o和O，通过数值前缀，可以用I、a、A等命令插入一整行的下划线或其他字符，不必重复输入许多字符

在vi中，采用删除后再放置文本的方法使文本移动

s最方便的用处之一是将一个字符换成多个字符
R在想更改文本但不知道确实数量时很有用

xp 对调两个字母

:set nu 显示行号
:set wm=10 设置与右边界的距离

**************************************************************************
w/W 使光标移动一个单词
b/B 使光标后退一个单词
e/E 移到单词的结尾

G 文件结尾
1G 文件顶端
42G 移动到42行

Ctrl-F 向前滚动一整屏
Ctrl-B 向后滚动一整屏
Ctrl-D 想下滚动半屏
Ctrl-U 向上滚动半屏

z Enter 将光标移动到屏幕顶端并滚动屏幕
z. 将光标移动到屏幕中心并滚动屏幕
z- 将光标移到屏幕底端并滚动屏幕

z可接受行号作为数值参数

Ctrl-L 重画屏幕

H 移到屏幕顶端的行
M 移到屏幕中央的行
L 移到屏幕底端的行

Enter 移动到下一行的第一个字符
+ 移动到下一行的第一个字符
- 移动到上一行的第一个字符

^ 移到当前行的第一个非空格处
n| 移到当前行的第n列

/ 往前搜索
? 往回搜索

e 移到单词的结尾
E 移到单词的结尾（忽略标点符号）
（ 移到当前句子的开头
） 移到下一个句子的开头
{ 移到当前这一段的开头
} 移到下一段的开头

fx 搜索（将光标移动到）本行中下一个出现x的地方，x代表任何字符
Fx 搜索（将光标移动到）本行中上一个出现x的地方
tx 搜索（将光标移动到）本行中下一个出现x的地方的前一个字符
Tx 搜索（将光标移动到）本行中上一个出现x的地方的后一个字符
; 重复上一个搜索命令，方向相同
,  重复上一个搜索命令，方向相反

dfx 会删除到下一个x字符为止的所有文本，包括x字符在内

上一次的搜索的模式会留在编辑器会话中。搜索过后，若要再次搜索上一个模式，不用重复原来的按键顺序，可以用一些命令来重复搜索。

n 往同一个方向重复搜索
N 往相反的反向重复搜索

Ctrl-G 在屏幕底端显示信息，包括当前行号、文件的总行数等。

mx 将当前位置标记成x（x可以是任何字符）
'x （单引号）将光标移到标记x所在行的第一个字符
`x (反引号）将光标移到以x标记的字符
`` （两个反引号）在移动位置之后，回到上一个标记或上下文的确切位置
'' (两个单引号）回到上一个标记或上下文所在行的开头

**************************************************************************
vi +n 在第n行代开file
vi +  在最后一行打开file
vi +/pattern file
在第一个出现pattern的地方打开file

vi -R file 用只读模式打开文件

vi -r file 可以恢复编辑缓冲区

:pre 强制系统没有死机也保存缓冲区，这在没有写入权限而不能保存时很有用

"2p 恢复倒数第二次的删除（位于缓冲区2）

"1pu.u.u 以此类推 遍历缓冲区

在做任何编辑前，必须先放置（p或P）未命名缓冲区的内容，不然缓冲区的内容就会被覆盖掉

vi会将最后9次的删除 操作保存在编号的缓冲区中，可以访问任何一个，恢复任何一次（或所有）的删除操作（小规模的删除，如一行中的一部分，不会保存到编号的缓冲区中。这些删除只能在刚做删除操作后立刻用p命令恢复）

vi将拖曳（复制）的文本放在依字母标识的缓冲区中。拖曳的文本可以被保存到26个缓冲区（a~z）中，并且可在编辑会话的任何时候，使用放置命令来恢复这些文本。

也可以将删除的文本保存到命名缓冲区

"dyy  将当前行拖曳到缓冲区d中
"a7yy 将后续7行拖曳到缓冲区a中
"dP   将缓冲d的内容放置在光标前
"ap   将缓冲a的内容放置在光标后
"a5dd 将删除的5行保存到缓冲区中

如果用大写字母指定缓冲区名字，则拖曳或删除的文本会被附加到当前缓冲区中。

可以在某个命名缓冲区中添加更多的文本。

**************************************************************************

vi命令模式中输入Q时会调用ex。输入命令vi会可回到vi编辑器。

在vi中输入ex命令时，命令前必须加上冒号，可以用完整的命令名称或缩写。

delete d 删除行
move   m 移动行
copy  co 复制行
       t 复制行

用空格来分隔ex命令的多个部分会比较容易读。例如在行地址、模式与命令间使用空格分隔。

不能再模式中使用空格区隔，也不能以空格作为替换命令的结尾

:= 列出文件的总行数
:.= 列出当前所在行的行号
:/pattern/= 列出pattern第一次出现时的行号

. 表示当前一行
$ 表示文件的最后一行
% 表示文件中的每一行，与1,$组合的意义相同

:.,$d 删除当前这一行到文件结尾间的文本
:20,.m$ 将第20行到当前这一行间的文本移到文件结尾
:%d   删除文件中所有的行
:%t$  将所有的行复制到文件结尾（做连续的复制）


+与-的操作类似于算术操作，放在数值前面时，其表示加上或减去后面的数值
在使用+或-时并不需要输入点好（.），因为当前行会被假定为开始的位置

:.,+20d 删除当前这一行到20行之后的行之间的文本
:226,$m.-2 将第226行到文件结尾间的行移到当前这一行的两行之前
:.,+20# 显示当前这一行及向下20行之间的行号

数字0表示文件的开头（想象中的第0行）
如果后面没有数字，+与-分别等于+1与-1

:-,+t0 复制3行（光标上面一行到光标下面一行）并放置到文件的开头

:/pattern/d 删除下一个包含pattern的行
:/pattern/+d 删除下一个包含pattern的行的下一行
:/pattern/,/pattern2/d 从第一个包含pattern1的行删除到第一个包含pattern2的行
:.,/pattern/m23
将当前这一行（.）到第一个包含pattern的行之间的文本放到第23行之后

d/pattern
vi对模式的删除命令会从光标所在位置删除到第一个pattern这个单词，但这两行剩下的部分会保留

:.,/pattern/d
ex的删除命令会删除指定行的所有文本，在这个例子中包括了当前这一行与包含模式的行，所有的行都会被全部删除

在ex中，用;代替逗号时，第一个行地址会被当成光标之前的地址。

:100;+5 p 第100行与它下面的5行
:/pattern/;+10 p 包含指定模式的下一行及后续10行

:g/pattern 寻找（移到）文件中最后一次出现pattern的地方
:g/pattern/p 寻找并显示文件中所有包含pattern的行
:g!/pattern/nu 寻找并显示文件中所有不包含pattern的行，也显示所有找到的行号
:60,124g/pattern/p 寻找并显示第60行与第124行之间包含pattern的行

在ex中，竖线（|）可以分隔命令，是在同一个ex提示符号下合并多个命令。
当使用|时，需记住所指定的行地址。如果某个命令影响了文件中各行的顺序，下一个命令将在新的行地址上运行

:1,3d | s/thier/their
删除第1行到第3行，接着在当前行做替换

:1,5 m 10 | g/pattern/nu
将第1行到第5行移到第10行之后，接着显示所有包含pattern的行

:230,$w newfile 将第230行到文件结尾保存成名为newfile的文件
:.,600w newfile 将光标所在的行到600行保存成名为newfile的文件

:1,10w newfile
:340,$w >> newfile
newfile会包含第1-10行以及第340行到缓冲区结尾间的两端内容

:r filename 把filename的内容插入到光标所在位置的下一行
:185r filename 指定位置的下一行插入 
:0r filename 将读入的文件放在当前文件的开头
:$r filename 将读入的文件放在当前文件的结尾
:/pattern/r filename 将读入的文件放在第一个出现pattern的行之后

vi file1 file2
可先编辑file1，然后使用ex命令:w写入file1，此时:n调用下一个文件
:args （简写为:ar）可列出命令行上的文件列表，当前编辑中的文件名称以方括号括起。
:rewind （简写为:rew）会将当前文件复位成命令行上的第一个文件
:last  将当前文件复位成命令行上的最后一个

不需要在编辑会话刚开始时就调用多个文件，而可以在任何时候用:e命令切换到另一个文件。vi会同时记住两个文件名，作为当前的与候补的文件名，它们可以用符号%（代表当前的文件名）与#（代表后补的文件名）来表示。
:e # 回到第一个文件
:r # 将第一个文件的内容读到当前的文件中

Ctrl-^ 切换文件，功能和:e #一样

使用:e命令将新的文件载入vi的缓冲区时，并不会清除命名缓冲区中的内容。因此，可先在一个文件中拖曳或删除文本，在用:e调用新的文件，然后把命名缓冲区的内容放置到新的文件中

**************************************************************************

:g 全局
:s 替换

:s/old/new 将当前行中第一个出现的模式old改成new
:s/old/new/g 将当前行中的每一个old更换成new
:50,100s/old/new 将第50行到第100行之间每一个出现的old更改为new
:1,$s/old/new/g 将整个文件中的old改为new（:%s/old/new/g）
:1,30s/old/new/gc 确认替换

:g/pattern/s/old/new/g
搜索一个模式，在找到包含模式的某一行时，对另外一个字符串做替换
:g/pattern/s//new/g 用于搜索的模式与用于替换的模式一样，就不必重复输入了

正则表达式可以与vi的搜索命令/与?一起使用，也包括ex的:g与:s命令

. 匹配出任何单一字符（换行符除外），空格也是字符

* 匹配出位于此符号前的单一字符，该字符可出现零到多次。*可以位于元字符后。
.*表示匹配出任何数量的任何字符

^
当^用在正则表达式的开头时，它后面的正则表达式必须位于一行的开头。
^Part只会匹配出位于一行开头的Part，而^...只匹配出一行的前三个字符。当不用在正则表达式的开头时，^就只代表其本意

$
当$用在正则表达式的结尾时，它前面的正则表达式必须位于一行的结尾。
here:$只会匹配出位于一行结尾的here:。当不是用在正则表达式的结尾时，$就只代表其本意

\
将其后面的特殊字符当成一般字符。组织特殊字符被解释为特殊意义，一般称为字符的转义
\.可匹配出实际的句号，而不是任意一个字符
\*可匹配出实际的星号
\\可匹配出反斜线字符

[]
匹配出方括号里的任何一个字符，如果匹配目标为一个范围的字符，则可用第一个字符加上连字符，再加上最后一个字符来表示
[AB]匹配出A或B
p[aeiot]t可匹配出pat、pet、pit、pot、put
[A-Z]会匹配出A到Z间的大写字母
[1-9]会匹配出0到9间的数字
[:;A-Za-z()]会匹配出4种标点符号加上所有的字母

大部分的元字符在括号内会失去特殊意义，因此可将他们当做一般字符匹配，并不需要转义
在方括号中仍然有三个元字符需要转义：\、-、] 

插入符号（^）只有位于方括号中的第一个时才有特殊意义，表示匹配出任何一个不在方括号中字符范围内的字符。
[^a-z]会匹配出任何不是小写字母的字符

\( \)
会将\(与\)之间的模式保存到特殊的空间，称为保留缓冲区。这种方法可以保存任意一行中的9个模式。
\(Thta\) or
\(this\)会将That存在保留缓冲区1中，而将this存到保留缓冲区2中。这些保留的模式在以后可以用\1到\9的序列重新显示
:%s/\(That\) or \(this\)/\2 or \1/ 将That or this改成this or That
也可以在搜索或替换字符串时使用\n表示法
:s/\(That\)\1/alphabet-soup/将abcdabcd缓冲alphabet-soup

\< \>
会匹配出以某些字符开头（\<）或结尾（\>）的单词。单词的结尾与开头是由标点符号或空格来分隔的。他们不需要成对使用
\<ac只会匹配出以ac开头的单词
ac\>只会匹配出以ac结尾的单词

