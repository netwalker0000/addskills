:sh 创建一个shell
Ctrl-D 结束shell并回到vi

:!commond 感叹号会告诉ex创建一个shell，并将后续文本视为Unix命令

0 移到一行的开头
$ 移到一行的结尾

ZZ 保存并离开文件
e! 恢复上一次存储的文件内容发
ls 列出文件

i 插入
a 添加
c 更改
d 删除
y 拖曳
p 放置
. 重复命令

~ 更改大小写
r 替换一个字符
s 替换多个字符
x 删除字符

u 撤销
Ctrl-R 重做

A 在一行的结尾处附加文本
I 在一行的开头处插入文本
o 在光标的下一行打开新行
O 在光标的上一行打开新行
J 合并两行

C 可更改光标所在位置到此行结尾间的文本,它的功用和c$一样
R 进入覆盖模式，输入的字符将逐一覆盖屏幕上的字符
S 更改一整行文本
D 删除从光标所在位置到本行结束间的文本
P 将文本放置在光标前
Y 拖曳一整行文本，与yy行为完全一样

U 恢复一整行成原来面貌

c 可以与光标移动命令一起使用
cw c2b c$ c0 cc

y 可与任何光标移动命令合并使用
yw y$ 4yy

yy 用于拖曳一整行的文本

除了o和O，通过数值前缀，可以用I、a、A等命令插入一整行的下划线或其他字符，不必重复输入许多字符

在vi中，采用删除后再放置文本的方法使文本移动

s最方便的用处之一是将一个字符换成多个字符
R在想更改文本但不知道确实数量时很有用

xp 对调两个字母

:set nu 显示行号
:set wm=10 设置与右边界的距离

**************************************************************************
w/W 使光标移动一个单词
b/B 使光标后退一个单词
e/E 移到单词的结尾

G 文件结尾
1G 文件顶端
42G 移动到42行

Ctrl-F 向前滚动一整屏
Ctrl-B 向后滚动一整屏
Ctrl-D 想下滚动半屏
Ctrl-U 向上滚动半屏

z Enter 将光标移动到屏幕顶端并滚动屏幕
z. 将光标移动到屏幕中心并滚动屏幕
z- 将光标移到屏幕底端并滚动屏幕

z可接受行号作为数值参数

Ctrl-L 重画屏幕

H 移到屏幕顶端的行
M 移到屏幕中央的行
L 移到屏幕底端的行

Enter 移动到下一行的第一个字符
+ 移动到下一行的第一个字符
- 移动到上一行的第一个字符

^ 移到当前行的第一个非空格处
n| 移到当前行的第n列

/ 往前搜索
? 往回搜索

（ 移到当前句子的开头
） 移到下一个句子的开头
{ 移到当前这一段的开头
} 移到下一段的开头

fx 搜索（将光标移动到）本行中下一个出现x的地方，x代表任何字符
Fx 搜索（将光标移动到）本行中上一个出现x的地方
tx 搜索（将光标移动到）本行中下一个出现x的地方的前一个字符
Tx 搜索（将光标移动到）本行中上一个出现x的地方的后一个字符
; 重复上一个搜索命令，方向相同
,  重复上一个搜索命令，方向相反

dfx 会删除到下一个x字符为止的所有文本，包括x字符在内

上一次的搜索的模式会留在编辑器会话中。搜索过后，若要再次搜索上一个模式，不用重复原来的按键顺序，可以用一些命令来重复搜索。

n 往同一个方向重复搜索
N 往相反的反向重复搜索

Ctrl-G 在屏幕底端显示信息，包括当前行号、文件的总行数等。

mx 将当前位置标记成x（x可以是任何字符）
'x （单引号）将光标移到标记x所在行的第一个字符
`x (反引号）将光标移到以x标记的字符
`` （两个反引号）在移动位置之后，回到上一个标记或上下文的确切位置
'' (两个单引号）回到上一个标记或上下文所在行的开头

**************************************************************************
vi +n 在第n行代开file
vi +  在最后一行打开file
vi +/pattern file
在第一个出现pattern的地方打开file

vi -R file 用只读模式打开文件

vi -r file 可以恢复编辑缓冲区

:pre 强制系统没有死机也保存缓冲区，这在没有写入权限而不能保存时很有用

"2p 恢复倒数第二次的删除（位于缓冲区2）

"1pu.u.u 以此类推 遍历缓冲区

在做任何编辑前，必须先放置（p或P）未命名缓冲区的内容，不然缓冲区的内容就会被覆盖掉

vi会将最后9次的删除 操作保存在编号的缓冲区中，可以访问任何一个，恢复任何一次（或所有）的删除操作（小规模的删除，如一行中的一部分，不会保存到编号的缓冲区中。这些删除只能在刚做删除操作后立刻用p命令恢复）

vi将拖曳（复制）的文本放在依字母标识的缓冲区中。拖曳的文本可以被保存到26个缓冲区（a~z）中，并且可在编辑会话的任何时候，使用放置命令来恢复这些文本。

也可以将删除的文本保存到命名缓冲区

"dyy  将当前行拖曳到缓冲区d中
"a7yy 将后续7行拖曳到缓冲区a中
"dP   将缓冲d的内容放置在光标前
"ap   将缓冲a的内容放置在光标后
"a5dd 将删除的5行保存到缓冲区中

如果用大写字母指定缓冲区名字，则拖曳或删除的文本会被附加到当前缓冲区中。

可以在某个命名缓冲区中添加更多的文本。

**************************************************************************

vi命令模式中输入Q时会调用ex。输入命令vi会可回到vi编辑器。

在vi中输入ex命令时，命令前必须加上冒号，可以用完整的命令名称或缩写。

delete d 删除行
move   m 移动行
copy  co 复制行
       t 复制行

用空格来分隔ex命令的多个部分会比较容易读。例如在行地址、模式与命令间使用空格分隔。

不能在模式中使用空格区隔，也不能以空格作为替换命令的结尾

:= 列出文件的总行数
:.= 列出当前所在行的行号
:/pattern/= 列出pattern第一次出现时的行号

. 表示当前一行
$ 表示文件的最后一行
% 表示文件中的每一行，与1,$组合的意义相同

:.,$d 删除当前这一行到文件结尾间的文本
:20,.m$ 将第20行到当前这一行间的文本移到文件结尾
:%d   删除文件中所有的行
:%t$  将所有的行复制到文件结尾（做连续的复制）


+与-的操作类似于算术操作，放在数值前面时，其表示加上或减去后面的数值
在使用+或-时并不需要输入点好（.），因为当前行会被假定为开始的位置

:.,+20d 删除当前这一行到20行之后的行之间的文本
:226,$m.-2 将第226行到文件结尾间的行移到当前这一行的两行之前
:.,+20# 显示当前这一行及向下20行之间的行号

数字0表示文件的开头（想象中的第0行）
如果后面没有数字，+与-分别等于+1与-1

:-,+t0 复制3行（光标上面一行到光标下面一行）并放置到文件的开头

:/pattern/d 删除下一个包含pattern的行
:/pattern/+d 删除下一个包含pattern的行的下一行
:/pattern/,/pattern2/d 从第一个包含pattern1的行删除到第一个包含pattern2的行
:.,/pattern/m23
将当前这一行（.）到第一个包含pattern的行之间的文本放到第23行之后

d/pattern
vi对模式的删除命令会从光标所在位置删除到第一个pattern这个单词，但这两行剩下的部分会保留

:.,/pattern/d
ex的删除命令会删除指定行的所有文本，在这个例子中包括了当前这一行与包含模式的行，所有的行都会被全部删除

在ex中，用;代替逗号时，第一个行地址会被当成光标之前的地址。

:100;+5 p 第100行与它下面的5行
:/pattern/;+10 p 包含指定模式的下一行及后续10行

:g/pattern 寻找（移到）文件中最后一次出现pattern的地方
:g/pattern/p 寻找并显示文件中所有包含pattern的行
:g!/pattern/nu 寻找并显示文件中所有不包含pattern的行，也显示所有找到的行号
:60,124g/pattern/p 寻找并显示第60行与第124行之间包含pattern的行

在ex中，竖线（|）可以分隔命令，是在同一个ex提示符号下合并多个命令。
当使用|时，需记住所指定的行地址。如果某个命令影响了文件中各行的顺序，下一个命令将在新的行地址上运行

:1,3d | s/thier/their
删除第1行到第3行，接着在当前行做替换

:1,5 m 10 | g/pattern/nu
将第1行到第5行移到第10行之后，接着显示所有包含pattern的行

:230,$w newfile 将第230行到文件结尾保存成名为newfile的文件
:.,600w newfile 将光标所在的行到600行保存成名为newfile的文件

:1,10w newfile
:340,$w >> newfile
newfile会包含第1-10行以及第340行到缓冲区结尾间的两端内容

:r filename 把filename的内容插入到光标所在位置的下一行
:185r filename 指定位置的下一行插入 
:0r filename 将读入的文件放在当前文件的开头
:$r filename 将读入的文件放在当前文件的结尾
:/pattern/r filename 将读入的文件放在第一个出现pattern的行之后

vi file1 file2
可先编辑file1，然后使用ex命令:w写入file1，此时:n调用下一个文件
:args （简写为:ar）可列出命令行上的文件列表，当前编辑中的文件名称以方括号括起。
:rewind （简写为:rew）会将当前文件复位成命令行上的第一个文件
:last  将当前文件复位成命令行上的最后一个

不需要在编辑会话刚开始时就调用多个文件，而可以在任何时候用:e命令切换到另一个文件。vi会同时记住两个文件名，作为当前的与候补的文件名，它们可以用符号%（代表当前的文件名）与#（代表后补的文件名）来表示。
:e # 回到第一个文件
:r # 将第一个文件的内容读到当前的文件中

Ctrl-^ 切换文件，功能和:e #一样

使用:e命令将新的文件载入vi的缓冲区时，并不会清除命名缓冲区中的内容。因此，可先在一个文件中拖曳或删除文本，在用:e调用新的文件，然后把命名缓冲区的内容放置到新的文件中

**************************************************************************

:g 全局
:s 替换

:s/old/new 将当前行中第一个出现的模式old改成new
:s/old/new/g 将当前行中的每一个old更换成new
:50,100s/old/new 将第50行到第100行之间每一个出现的old更改为new
:1,$s/old/new/g 将整个文件中的old改为new（:%s/old/new/g）
:1,30s/old/new/gc 确认替换

:g/pattern/s/old/new/g
搜索一个模式，在找到包含模式的某一行时，对另外一个字符串做替换
:g/pattern/s//new/g 用于搜索的模式与用于替换的模式一样，就不必重复输入了

正则表达式可以与vi的搜索命令/与?一起使用，也包括ex的:g与:s命令

. 匹配出任何单一字符（换行符除外），空格也是字符

* 匹配出位于此符号前的单一字符，该字符可出现零到多次。*可以位于元字符后。
.*表示匹配出任何数量的任何字符

^
当^用在正则表达式的开头时，它后面的正则表达式必须位于一行的开头。
^Part只会匹配出位于一行开头的Part，而^...只匹配出一行的前三个字符。当不用在正则表达式的开头时，^就只代表其本意

$
当$用在正则表达式的结尾时，它前面的正则表达式必须位于一行的结尾。
here:$只会匹配出位于一行结尾的here:。当不是用在正则表达式的结尾时，$就只代表其本意

\
将其后面的特殊字符当成一般字符。组织特殊字符被解释为特殊意义，一般称为字符的转义
\.可匹配出实际的句号，而不是任意一个字符
\*可匹配出实际的星号
\\可匹配出反斜线字符

[]
匹配出方括号里的任何一个字符，如果匹配目标为一个范围的字符，则可用第一个字符加上连字符，再加上最后一个字符来表示
[AB]匹配出A或B
p[aeiot]t可匹配出pat、pet、pit、pot、put
[A-Z]会匹配出A到Z间的大写字母
[1-9]会匹配出0到9间的数字
[:;A-Za-z()]会匹配出4种标点符号加上所有的字母

大部分的元字符在括号内会失去特殊意义，因此可将他们当做一般字符匹配，并不需要转义
在方括号中仍然有三个元字符需要转义：\、-、] 

插入符号（^）只有位于方括号中的第一个时才有特殊意义，表示匹配出任何一个不在方括号中字符范围内的字符。
[^a-z]会匹配出任何不是小写字母的字符

\( \)
会将\(与\)之间的模式保存到特殊的空间，称为保留缓冲区。这种方法可以保存任意一行中的9个模式。
\(Thta\) or
\(this\)会将That存在保留缓冲区1中，而将this存到保留缓冲区2中。这些保留的模式在以后可以用\1到\9的序列重新显示
:%s/\(That\) or \(this\)/\2 or \1/ 将That or this改成this or That
也可以在搜索或替换字符串时使用\n表示法
:s/\(abcd\)\1/alphabet-soup/将abcdabcd缓冲alphabet-soup

\< \>
会匹配出以某些字符开头（\<）或结尾（\>）的单词。单词的结尾与开头是由标点符号或空格来分隔的。他们不需要成对使用。当两者同时使用时，可限制单词必须完整才进行模式匹配。
\<ac只会匹配出以ac开头的单词
ac\>只会匹配出以ac结尾的单词
:%s/\<child\>/children/g 搜索所有的单词child

在POSIX标准中，方括号内的字符组称为方括号表达式。在方括号号表达式中，除了a、！等文字字符之外，还可以有其他的元素，包括：字符类，校对符号，等价类。

在做全局替换时，元字符只在命令的搜索部分中有特殊意义

在替换字符串中有特殊意义的元字符：\n、\、&

\n
利用\(与\)存储的第n个模式的文字做代替，n表示为数字1到9，而之前存储的模式（位于保留缓存区）是从行左至行右来计算的。
\ 将后面一个特殊字符当成一般字符。

&
用在替换字符串中，会被替换成搜索模式中匹配出的完整文本，这在避免重新输入文本时很有用
:%s/Yazstremski/&, Carl/

\u或\l 是替换字符串中的下一个字符变成大写或小写
:%s/yes, doctor/\uyes, \udoctor/
:%s/\(That\) or \(this\)/\2 or \1/

\U或\L与\e或\E
\U与\L使所有接在后面的字符都会被转换成大写或小写的，一直到替换字符串结束，或出现\e或\E为止。如果没有\e或\E，所有的文本都会被\U或\L所影响。
:%s/Fortran/\UFortran/
:%s/Fortran/\U&/

除了/字符，分隔字符亦可为任何非字母、非数值、非空格的字符，但是反斜线(\)、双引号(")与竖线(|)例外，这在更改路径名称时很有用
:%s;/user1/tim;/home/tim;g

:g/mg\([ira]\)box/s//mg\1square/g 保留单词前缀，替换后面部分
:g /SYNTAX/.,/DESCRIPTION/-1 move /PARAMETERS/-1
将description块移到syntax块之上
:g/DESCRIPTION/,/PARAMTERS/-1d 删除所有的description块

在单词ENTER前后加上troff的斜体代码
:%s/RETURN/\\fI&\\fp/g 在单词enter前加上troff的斜体代码

更改文件中的路径名称
:%s/\/home/tim/\/home\/linda/g
:%s:/home/tim:/home/linda:g
斜线（当做全局替换序列的分隔符）如果是替换文本或模式的一部分时，必须用反斜线做转义，即用\/才能用到/。另一个效果相同的方法是用其他字符当做模式的分隔符号。

将第1至第10行中的所有句号改为分号
:1,10s/\./;/g

将所有出现的help（或Help）改为HELP
:%s/[Hh]elp/HELP/g
:%s/[Hh]elp/\U&/g

将一个或多个空格替换成一个空格
:%s/  */ /g

将冒号后面的一个或多个空格换成两个空格
:%s/:  */:  /g 

将某号或句号后面的一个或多个空格换成两个空格
:%s/\([:.]\)  */1  /g 

将标题或单词的各种用法标准化
:%s/^Note[ :s]*/Notes: /g

删除所有的空白行
:g/^$/d
实际上要匹配出以行开头（^）为开头，以行结尾（$）为结尾，中间没有内容的行

删除所有的空白行以及所有只包含空格的行
:g/^[ 	]*$/d
:g/^[ 	][ 	]*$/d

删除每一行开头的所有空白
:g/^  *\(.*\)/\1/

删除每一行结尾的所有空白
:%s/\(.*\)  *$/\1/

在文件中每一行的开头加上>
:%s/^/>  /
^一行的开头时逻辑上的概念，不是实际的字符，不会真的被换掉

为后续6行的结尾加上句号
:.,+5s/$/./
￥是一个逻辑上的概念，行的结尾不会真的被替换

逆转所有用连字符分隔部分的顺序
:%s/\(.*\) - \(.*\)/\2 - \1/

将文件中的每一个单词全变成大写的
:%s/.*/\U&/

逆转文件中各行的次序
:g/^/move0

在文本文件数据库中，对所有不包含Paid in full的行加上Overdue一词
:g!/Paid in full/s/$/Overdue/
:v/Paid in full/s/$/Overdue/

将所有不是由数字开头的行移到文件结尾
:g!/^[0-9]/m$
:g/^[^0-9]/m$

将文件小标题中的数字删除
:%s/^[1-9][0-9]*\.[1-9][0-9.]* //

**************************************************************************

Unix命令行行为
单一字母选项前需加上-（一个连字符）
类似一般词汇的选项前需加上--（两个连字符）
只包含两个连字符的命令行参数，则表示该命令行并未包含选项

vim启动与初始化选项
-b 在二进制模式中编辑
-c command command将被视为ex命令执行。Vim在一条命令中最多允许加入10个-c选项
-d
以diff模式启动。Vim执行对2-4个文件的diff功能以及可设置选项来简化文件差异的查看。
-o 所有文件均各自打开窗口。
-O 与-o一样，但打开垂直分隔的窗口

与命令名称相关的行为
vim 启动文字版Vim
view 以只读模式启动Vim，与vim -R相同
vimdiff 以diff模式启动并比较文件的差异

vimrc文件时配置Vim的编辑特性较好的地方，差不多任何Vim选项都能在此文件中被设置为打开或关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射。
注释以双引号（"）开始，可位于一行的任何位置。所有位于双引号后的文本，包括双引号，都会被忽略
可用（亦可不用）某号表示ex命令
如果一大组选项定义能分开为不同行，这个文件将容易管理。

:split 创建水平分割编辑窗口
:vsplit 创建垂直分割编辑窗口
:splite otherfile 浏览另一个文件

分割窗口的选项
Ctrl-W-s
:[n]split [++opt] [+cmd] [file]
n 为Vim指定在新窗口中显示的行数，新窗口位于画面顶端
opt 传递Vim选项信息给新的窗口会话
cmd 传入欲在新窗口中执行的命令
file 指定欲在新窗口中编辑的文件

Ctrl-W-n
:[n]new [++opt] [+cmd] [file]
可以打开一个水平窗口，自动命令WinLeave、WinEnter、BufLeave、BufEnter也被执行了

Ctrl-W-v
:[n]vsplit [++opt] [+cmd] [file]

:[n]vnew [++opt] [+cmd]

:[n]sview [++opt] [+cmd] [file] 只读版的：split
:[n]sfind [++opt] [+cmd] [file] 

set mouse=a 为所有用途——命令行、输入、导航都激活鼠标的使用

Ctrl-W <down>
Ctrl-W Ctrl-J
Ctrl-W j
光标移到下一个窗口

Ctrl-W <up>
Ctrl-W Ctrl-K
Ctrl-W k
光标移到上一个窗口

Ctrl-W <left>
Ctrl-W Ctrl-H
Ctrl-W h
光标移动到左边的窗口

Ctrl-W <right>
Ctrl-W Ctrl-L
Ctrl-W l
光标移动到右边的窗口

Ctrl-W Ctrl-W
Ctrl-W w
光标在所有的Vim窗口间循环移动

Ctrl-W Ctrl-T
Ctrl-W t
光标移动到最左上角的窗口

Ctrl-W Ctrl-B
Ctrl-W b
光标移动到最右下角的窗口

Ctrl-W Ctrl-P
Ctrl-W p
光标移动到前一个（最后访问的）窗口

Ctrl-W r
向右或向下轮换窗口
Ctrl-W R
向左或向上轮换窗口
Ctrl-W x
与下一个窗口交换位置

Ctrl-W K
移动窗口至屏幕顶端并使用全部宽度，光标一直在移动的窗口里
Ctrl-W J
移动窗口至屏幕底端并使用全部宽度，光标一直在移动的窗口里
Ctrl-W H
移动窗口至屏幕左端并使用全部高度，光标一直在移动的窗口里
Ctrl-W L
移动窗口至屏幕右端并使用全部高度，光标一直在移动的窗口里
Ctrl-W T
移动窗口至新分页，光标一直在移动的窗口里，如果当前的窗口是当前分页里的唯一窗口，则不会发生任何操作

Ctrl-W =
调整所有窗口至相同尺寸
Ctrl-W -
将当前窗口的高度减少一行
Ctrl-W +
将当前窗口的高度增加一行
:resize n
设置当前窗口的水平尺寸为n行
Ctrl-W <
减少窗口的宽度
Ctrl-W >
增加窗口的宽度
Ctrl-W |
调整当前窗口至可能的最大宽度

使用命令:ls、:files、:buffers列出缓冲区
每个缓冲区有独一无二、不会改变的编号。每个缓冲区编号右侧，首先列出的是状态标志。
u 非列出缓冲区。这个缓冲区不会列出，除非使用!
%或# %表示当前窗口坐在的缓冲区。#表示使用:edit #后跳转的缓冲区
a或h
a表示活动中的缓冲区，意为该缓冲区已载入且可见。h表示隐藏的缓冲区，它虽然存在，不能再任何窗口中查看
-或=
-表示缓冲区把modifiable选项关闭了，这个文件为只读文件。=则表示该文件是不能把状态修改为可调整的只读文件
+或x +之处缓冲区可以调整。x表示缓冲区具有读入错误


分页编辑
:tabnew filename
打开新分页并编辑新文件
:tabclose
关闭当前的分页
:tabonly
关闭其他的分页。若果其他分页中有修改过的文件，则不会移动该分页，除非设置了autowrite选项。
Ctrl-[PAGE_DOWN]
向右移动一个分页
Ctrl-[PAGE_UP]
向左移动一个分页


**************************************************************************

创建折叠的6中方式
manual 以标准Vim结构定义折叠跨越的范围，类似移动命令
indent 折叠与折叠的层次，对于文本的缩排与shiftwidth选项值
expr   以正则表达式定义折叠
syntax 折叠对应于文件所用的程序语言语义
diff   以两个文本间的差异定义折叠
marker 以文件中的预定义（亦可由用户定义）标记指定折叠边界

所有的方式对折叠的控制（打开与关闭、删除等等）都一样

:mkview与:loadview 可在会话间保留折叠，不需再次创建

:set foldcolumns=n 实则之折叠的可视线索
n是可视折叠线索使用的列数（最大为12，默认为0）

zA 递归切换折叠状态
zC 递归关闭折叠
zD 递归删除折叠
zE 去除所有折叠
zf
创建折叠，范围从当前的行开始到光标移动后到达的位置结束（借由移动命令改变光标位置）
countzF 创建涵盖count行的折叠
zM 设置foldlevel选项为0
zN, zn 设置（zN）或复位（zn）foldenable选项
zo 递归打开折叠
za 切换一个折叠的状态
zc 关闭一个折叠
zd 删除一个折叠
zi 切换foldenable选项
zj, zk 移动光标至下一个折叠开始的地方（zj），或移动至前一个折叠的结尾处（zk）
zm, zr 递减（zm）或递增（zr）foldlevel选项
zo 打开一个折叠

3zF 折叠三行
2zfj/zf2j 折叠三行
zf% 光标在代码块的开始或结尾括号（{或}）时，折叠代码块
zfgg 创建从光标位置直达文件开始处的折叠（gg移动光标到文件的开始处）

:set foldcolumns=n
折叠可视线索，n是可视折叠线索使用的列数（最大为12，默认为0）

大纲
:set foldmethod=indent
:set shiftwidth=4
:set foldlevel=n
每个shiftwidth遇到有缩排的行，该行折叠层次即递增1
foldlevel控制可见的折叠层次。它接受一个参数，只显示折叠层次小于等于参数的行的内容

程序语义折叠
:set foldenable 确认折叠功能已打开
:set foldmethod=syntax


**************************************************************************

缩排方式（依其复杂度排列）
autoindent 模仿vi的autoindent，两者的差异仅在于缩排删除后的光标位置
smartindent 比autoindent稍微强大一点，能识别基础C语法元素，用于定义缩排层次
cindent 嵌入了更多C语法理解能力，并在简单的缩排层次上引入了复杂的自定义方式。
indentexpr 能让我们自定义表达式，Vim则根据开始每个新行时的上下文评估表达式。

Vim的autoindent的行为几乎就像vi的同名功能，可借由设置compatible选项予以区分。
Vim可识别文件的“类型”，当文件的某行注释环绕到新的一行时，它会适当地加上注释字符。这项功能与wrapmargin（文本遇到规定的右边界warpmargin栏即换行绕排）或textwidth（当一行的字符数超过textwidth设置的字符即换行绕排）协同运作。设置compatible选项后（用于模仿vi的行为），textwidth选项将失效，文本只会因wrapmargin的值绕排。

smartindent自动插入缩排的时机
接在{后的下一行
以cinwords选项中包含的关键字开始的行
如果光标位于包含右花括号（}）的行且用户使用O命令（在当前位置的上方打开新行）创建新的一行，则新的一行创建在以}开始的行前
内容以右花括号（}）结尾的新行

cindent对大多数编程任务而言更为使用。它的许多设置已满足大多数程序员的需要（共同标准）
cindent的动作通过三个选项定义：
cinkeys 定义让Vim重新估算缩排的键盘按键组合
cinoptions 定义缩排样式（style）
cinwords 定义标志着Vim应于后续内容行中加入额外缩排的关键字

cinkeys是以逗号分隔的一些值：
0{, 0}, 0), :, 0#, !^X^F, o, 0, e

o{
0为后面{字符设置一行开头的上下文。如果一行中输入的第一个字符为{，Vim将重新估算该行的缩排。
0表示如果字符输入的位置是一行的开头处
{默认的缩排距离为零：除了现有的缩排层次，不另行增加缩排。

0}，0)
这两个选项设置一行开头的上下文。若于行开头输入}或),Vim重新估算缩排
}默认的缩排距离与成对的开始括号{定义的缩排距离相同
)的缩排距离则是一个shiftwidth

:
这是C的标签（label）或case statement上下文
如果:是标签或case statement语句的结尾，Vim即重新估算缩排
:的默认缩排距离为1，即该行的第一栏。
零缩排让新行与前一行维持相同的缩排层次，而当缩排距离为1，新行的第一个字符则向左移到第一栏

 0#
一行开头的上下文
当#是某行中输入的第一个字符时，Vim即重新估算缩排

!^F
特殊字符!定以后续的字符为重新估算当前行中的缩排的触发器。
^F代表CTRL-F，所以默认行为是让Vim在我们按下CTRL-F时重新估算当前所在行的缩排

o
这个上下文定以我们创建的任何新行，无论是于插入模式中按Enter键，或是使用o命令（打开新行）

O
这个上下文涵盖使用O命令在当前的文本行之上新行的创建

e
这是else情况，如果某行以else初始化，Vim即重新估算缩排。知道else的最后一个"e"输入前，Vim都不会识别这种情况

cinkeys syntax rules（cinkeys语法规则）
! 指示Vim重新估算当前行缩排的按键
* 要求Vim在插入指定按键前重新估算当前行的缩排
0
设置一行开头的上下文。指定在0后的按键只在输入一行的第一个字符时才触发缩排的重新估算

cinkeys关键字选项
<> 使用此形式照字面定义关键字。对于特殊的非打印键，则使用它的念法。
例如，字面量字符":"可定义为<:>，非打印键向上箭头可定义为<Up>
^ 代表控制字符
o O e
=word =~word
使用这些定义接受特殊行为的词汇。一旦出现匹配的字符串word，而且是新行的第一个文本，Vim即重新估算安排
=~word的形式与=word完全一样，但它忽略大小写差异

cinwords
cinwords定义关键字，输入这些关键字时，将在下一行触发额外的缩排。
此选项的默认值是：if, else, while, do, for, switch

cinoptions
cinoptions控制Vim在C的上下文中重新缩排文本行的行为，其中包括控制一些代码格式化标准的设置
由花括号（{}）括起的代码块的缩排距离
当花括号接在条件语句后时是否插入新的行
如何根据括起代码块的花括号而对齐

cinoptins默认值
s, e0, n0, f0, {0, }0, ^0, :s, =s, l0, b0, gs, hs, ps, ts, is, +s, c3, C0, /0,
(2s, us, U0, w0, W0, m0, j0, )20, *30

indentexpr
如果定义了indentexpr，它将覆盖cindent，使我们自定义缩排规则。
indentexpr定义表达式，文件中每次创建新行时都要估算此表达式。这个表达式决定Vim用于新行缩排的整数

$VIMRUNTIME/indent目录，已设计好多种语言的缩排规则。
在.vimrc文件中加入filetype命令，可以要求Vim自动检测文件类型，并载入对应的缩排文件
可使用:filestype indent off命令关闭缩排

不做自动缩排时
任何时候，只要在编辑会话中手动对自动缩排的行改变它的缩排方式，Vim将为改行加上标志，以后不会再试着对改行自动缩排

复制与黏贴
当我们黏贴文本到文件中打开自动缩排的地方时，Vim吧黏贴的文本视为一般输入而应用所有自动缩排规则。
设置Vim的paste选项，调整Vim的所有自动功能，以保证仅仅黏贴文本。
设置:set nopaste，回到自动缩排模式


**************************************************************************

关键字与字典词汇补全
除了complete关键字，所有与补全相关的命令以CTRL-X开始，第二组命令则特别定义Vim要尝试的补全类型。

CTRL-X CTRL-F 自动补全文件名称

所有的补全方式几乎都有一样的行为：在我们输入第二组按键时，会循环重复一份候补补全内容名单。
以CTRL-X
CTRL-F选择文件名称的自动补全为例，如果第一次没有出现正确的字，我们可以重复按下CTRL-F以查看其它选择。

CTRL-N 下一个
CTRL-P 前一个

CTRL-X CTRL-L 补全整行

CTRL-X CTRL-N 在当前文件中向前搜索匹配光标前方字符的关键字

CTRL-E 停止匹配且不替换任何文本

CTRL-X CTRL-K
向前搜索在dictionary选项中定义的关键字，寻找是否匹配光标前方字符的关键字
dictionary选项的默认值未定义，在下方几个地方常常能找到dictionary文件
/usr/dict/words (在XP上的Cygwin)
/usr/share/dict/words
$HOME/.mydict

CTRL-X CTRL-T
向前搜索有thesaurus选项定义的文件，寻找是否有匹配光标前方字符的关键字
如果在thesaurus文件中的那一行包含多个词汇，Vim则把所有列出的词汇放入候补列表里

CTRL-X CTRL-I 向前搜索当前文件及包含文件中匹配光标前方字符的关键字
CTRL-X CTRL-P 搜索当前文件

CTRL-X CTRL-J 向前搜索当前标签与包含文件中匹配标签（tag）的关键字

CTRL-X CTRL-D 向前搜索当前文件及包含文件中宏名称及#define指令所做的定义

CTRL-X CTRL-V 设置用于Vim命令行并试图猜测补全词汇的最佳选择

CTRL-X CTRL-U
以自己定义的函数定义补全内容。Vim使用completefunc选项指定的函数进行补全

CTRL-X CTRL-O
使用自定义函数，这个方法预期函数依文件类型而不同，因而在载入文件时即决定载入所需函数。
omni的补全文件亦可支持C、CSS、HTML、JavaScript、PHP、Python、Ruby、SQL、XML

CTRL-X CTRL-S 以光标前的字符作为基础，让Vim提供补全词汇的候选列表

CTRL-N 最通用的选项，可以让我们结合其他所有搜索。
在complete选项中，设置可用来用来源列表（其间以逗号分隔），即定义了补全行动的地点及方式。么个可用来源用一个字符代表：
. 搜索当前的缓冲区
w 搜索其他窗口的缓冲区
b 搜索缓冲区列表中其他已载入的缓冲区
u 搜索缓冲区列表中未载入的缓冲区
U 搜索不在缓冲区列表中的缓冲区
k 搜索字典文件（列在dictionary选项中）
kspell 使用当前的拼写检查方案
s 搜索同义词文件（列在thesaurus选项中）
i 搜索当前文件与包含文件
d 在当前文件与包含文件中搜索定义的宏
t、] 为了补全标签而搜索


**************************************************************************

语法高亮
:syntax enable

:syntax on

:set syntax=sh 强制使用选择的语法高亮显示方式（Vim）
